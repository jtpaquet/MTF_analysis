# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'app.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import Qt, QtCore, QtGui, QtWidgets, uic

from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT, FigureCanvasQTAgg
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
from matplotlib import rcParams


from scipy.fft import fft, ifft, fftshift, fftfreq
from scipy.interpolate import interp1d
from scipy.optimize import curve_fit
from scipy.signal import blackman

import numpy as np
import pandas as pd
import json
import time
import sys
import os

rcParams.update({'figure.autolayout': True})

ui_MainWindow, qmain_window = uic.loadUiType("app.ui")

class control_ui(qmain_window, ui_MainWindow):
    def __init__(self, parent=None):
        super(control_ui, self).__init__(parent)

        self.df = pd.DataFrame({})
        self.filename = 'zoom2.txt'
        self.data = {}
        self.zoom = 2
        self.units = "mm"

        # Variables for app
        self.setupUi(self)

        self.actionOpen_data.triggered.connect(self.openImg)
        self.actionAbout.triggered.connect(self.about)

        # Img to analyze
        self.imgFig = Figure()
        self.imgCanvas = FigureCanvasQTAgg(self.imgFig)
        self.graph_img_layout.addWidget(self.imgCanvas)

        # Mean signal
        self.signalFig = Figure()
        self.signalCanvas = FigureCanvasQTAgg(self.signalFig)
        self.graph_signal_layout.addWidget(self.signalCanvas)

        # Mean PSF
        self.psfFig = Figure()
        self.psfCanvas = FigureCanvasQTAgg(self.psfFig)
        self.graph_psf_layout.addWidget(self.psfCanvas)

        # Mean MTF
        self.mtfFig = Figure()
        self.mtfCanvas = FigureCanvasQTAgg(self.mtfFig)
        self.graph_mtf_layout.addWidget(self.mtfCanvas)
        self.mtfButton.clicked.connect(self.updateMTF)
        
        # Update graphs
        self.updateMTF()
        
    
    def __del__(self):
        return
             
        
    def about(self):
        self.dialog = QtWidgets.QDialog(self)
        self.dialog.setWindowTitle("About")
        self.aboutLayout = QtWidgets.QVBoxLayout(self.dialog)
        self.aboutLabel = QtWidgets.QLabel(self.dialog)
        self.aboutLayout.addWidget(self.aboutLabel)
        self.aboutLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.aboutLabel.setText("\nPSF- UL\n\nJérémy Talbot-Pâquet, 2020\n\nVersion: 1.0\n")
        self.dialog.show()

    
    def loadData(self, filename):
        self.title = filename.split('/')[-1]
        self.title = self.title.split(".")[0]
        self.df = pd.read_csv(filename, sep="\t")
    

    def updateImg(self):
        self.loadData(self.filename)
        # Make fig
        self.imgFig.clear()
        ax = self.imgFig.add_subplot(111)
        ax.imshow(self.df)
        ax.set_title(self.title)
        self.imgCanvas.draw()


    def updateSignal(self):
        self.updateImg()
        # Make fig
        self.signalFig.clear()
        ax = self.signalFig.add_subplot(111)
        # Get parameters
        self.px_ratio = float(self.scaleTextEdit.text())
        if self.px_ratio >= 1e3:
            self.px_ratio  = self.px_ratio / 1e3
            self.units = "µm"
        self.n_idx = int(self.neighborSpinBox.value())
        treshold = self.thresholdSpinBox.value()
        # Get data
        values = self.df.mean(axis=0)
        std = self.df.std(axis=0)
        values = np.array(values)
        x = np.arange(len(values))/self.px_ratio
        self.deriv = abs(np.diff(values))
        treshold = np.percentile(self.deriv, treshold)
        x_deriv = x[1:] + 0.5*1/self.px_ratio
        mask = self.deriv > treshold
        split_indices = np.where(mask)[0]
        idx_max = []
        for msk in consecutive(split_indices):
            idx_max.append(np.where(self.deriv == max(self.deriv[msk])))
        self.idx = []
        idx_max = np.array(idx_max).flatten().astype(int)
        for i_max in idx_max:
            self.idx.append(np.arange(i_max-self.n_idx, i_max+self.n_idx+1))
        # Plot
        ax.plot(x, values, linewidth=0.6, label="signal", c="C0")
        ax.plot(x_deriv, self.deriv, linewidth=0.6, label="derivative", c="C1")
        ax.scatter(x_deriv[idx_max], self.deriv[idx_max], marker="x", linewidths=0.7, c="C2", label="mask")
        for psf in self.idx:
            ax.plot(x_deriv[psf], self.deriv[psf], linewidth=0.6, c="C2")
        ax.set_xlabel(f"$x$ [{self.units}]")
        ax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.1), ncol=3)
        self.signalCanvas.draw()


    def updatePSF(self):
        self.updateSignal()
        # Make fig
        self.psfFig.clear()
        ax = self.psfFig.add_subplot(111)
        # Get parameters
        interp_kind = str(self.interpPsfComboBox.currentText())
        # Get data
        psf = []
        for i in self.idx:
            self.x_psf = i / self.px_ratio - np.mean(i) / self.px_ratio
            psf.append(self.deriv[i])
        self.N_psf = len(psf)
        N_interp = int(1e3)
        psf = np.array(psf)
        std = np.std(psf, axis=0)
        self.psf = np.mean(psf, axis=0)
        max_psf = float(max(abs(self.psf)))
        self.psf = self.psf / max_psf
        self.f_psf = interp1d(self.x_psf, self.psf, kind=interp_kind)
        self.x_new = np.linspace(self.x_psf[0], self.x_psf[-1], N_interp)
        # Plot
        plt.errorbar(self.x_psf, self.psf, yerr = std, fmt="none", linewidth=0.8, color="black")
        for psf_ in psf:
            ax.plot(self.x_psf, psf_/max_psf, linewidth=0.6, alpha=0.2, c="black")
        ax.plot(self.x_new, self.f_psf(self.x_new), label=f"N = {self.N_psf}", linewidth=0.8, color="black")
        ax.set_xlabel(f"$x$ [{self.units}]")
        ax.legend()
        self.psfCanvas.draw()


    def updateMTF(self):
        self.updatePSF()
        # Make fig
        self.mtfFig.clear()
        ax = self.mtfFig.add_subplot(111)
        # Get parameters
        interp_kind = str(self.interpMtfComboBox.currentText())
        # MTF avec FFT de PSF
        N = len(self.x_new)
        dx = 1/self.px_ratio
        w = blackman(N)
        ywf = fft(self.f_psf(self.x_new)*w)
        ywf /= max(abs(ywf))
        xf = fftfreq(N, dx)
        xf = fftshift(xf)
        yplot = fftshift(ywf)
        MTF = interp1d(xf, abs(yplot), kind=interp_kind)
        xf_new = np.linspace(0, max(xf), 1000)
        y_MTF = MTF(xf_new)
        res = min(xf_new[y_MTF < 0.09])
        xf_new = np.linspace(0, 3*res, 1000)
        y_MTF = MTF(xf_new)
        # Plot
        ax.scatter(xf, np.abs(yplot), linewidth=0.8, color="black", marker=".", s=3**2)
        ax.plot(xf_new, y_MTF, linewidth=0.8, color="black", label="MTF")
        # ax.scatter(res, MTF(res), marker="x", linewidths=1, s=5**2, color="black")
        ax.set_xlim([0, 3*res])
        ax.set_ylim([-0.05, 1.05])
        ax.set_xlabel(f"$f$ [cycle/{self.units}]")
        ax.legend()
        lim_nyquist = self.px_ratio/2
        # Compile data
        # self.data[f"{2}"] = [self.n_idx*2+1, self.N_psf, res, lim_nyquist]
        self.mtfCanvas.draw()

    def openImg(self):        
        self.filedialog = QtWidgets.QFileDialog()
        self.filedialog.setFileMode(QtWidgets.QFileDialog.AnyFile)
        self.filedialog.setNameFilters(["Sequence files (*.txt)", "All files (*)"])
            
        if self.filedialog.exec_():
            self.filename = self.filedialog.selectedFiles()[0]
            self.loadData(self.filename)
            self.updateMTF()


class Worker(QtCore.QRunnable):
    '''
    Worker thread

    Inherits from QRunnable to handler worker thread setup, signals and wrap-up.

    :param callback: The function callback to run on this worker thread. Supplied args and 
                     kwargs will be passed through to the runner.
    :type callback: function
    :param args: Arguments to pass to the callback function
    :param kwargs: Keywords to pass to the callback function
    
    '''

    def __init__(self, fn, *args, **kwargs):
        super(Worker, self).__init__()
        # Store constructor arguments (re-used for processing)
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()


    @QtCore.pyqtSlot()
    def run(self):
        '''
        Initialise the runner function with passed args, kwargs.
        '''
        self.fn(*self.args, **self.kwargs)


class WorkerSignals(QtCore.QObject):
    result = QtCore.pyqtSignal(object)


def consecutive(data, stepsize=1):
    return np.split(data, np.where(np.diff(data) != stepsize)[0]+1)


if __name__ == "__main__":
    import sys
    MainEvntThread = QtWidgets.QApplication([])
    ui = control_ui(None)
    ui.show()
    MainEvntThread.exec()
